// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.16.3 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/gofiber/fiber/v2"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for UserRole.
const (
	Artist   UserRole = "artist"
	Listener UserRole = "listener"
)

// Album defines model for Album.
type Album struct {
	ArtistId    *openapi_types.UUID `json:"artist_id,omitempty"`
	ArtistName  *[]string           `json:"artist_name,omitempty"`
	Id          *openapi_types.UUID `json:"id,omitempty"`
	Price       *float32            `json:"price,omitempty"`
	ReleaseDate *openapi_types.Date `json:"release_date,omitempty"`
	Songs       *[]Song             `json:"songs,omitempty"`
	Title       *string             `json:"title,omitempty"`
}

// LoginResponse defines model for LoginResponse.
type LoginResponse struct {
	Token *string `json:"token,omitempty"`
	User  *User   `json:"user,omitempty"`
}

// Purchase defines model for Purchase.
type Purchase struct {
	AlbumId   *openapi_types.UUID `json:"album_id,omitempty"`
	CreatedAt *time.Time          `json:"created_at,omitempty"`
	Id        *openapi_types.UUID `json:"id,omitempty"`
	SongId    *openapi_types.UUID `json:"song_id,omitempty"`
	UpdatedAt *time.Time          `json:"updated_at,omitempty"`
	UserId    *openapi_types.UUID `json:"user_id,omitempty"`
}

// Song defines model for Song.
type Song struct {
	AlbumId      *openapi_types.UUID `json:"album_id"`
	ArtistId     *openapi_types.UUID `json:"artist_id"`
	ArtistsNames []string            `json:"artists_names"`

	// AudioUrl URL to the song's audio file
	AudioUrl  *string    `json:"audio_url,omitempty"`
	CreatedAt time.Time  `json:"created_at"`
	DeletedAt *time.Time `json:"deleted_at"`

	// Duration Duration of the song in seconds
	Duration *int               `json:"duration"`
	Genre    string             `json:"genre"`
	Id       openapi_types.UUID `json:"id"`

	// IsPurchased Indicates if the song is purchased
	IsPurchased bool       `json:"is_purchased"`
	Price       *float32   `json:"price"`
	ReleaseDate *time.Time `json:"release_date"`
	Title       string     `json:"title"`
	UpdatedAt   time.Time  `json:"updated_at"`
}

// Tip defines model for Tip.
type Tip struct {
	Amount   *float32            `json:"amount,omitempty"`
	ArtistId *openapi_types.UUID `json:"artist_id,omitempty"`
	Id       *openapi_types.UUID `json:"id,omitempty"`
	Message  *string             `json:"message,omitempty"`
	UserId   *openapi_types.UUID `json:"user_id,omitempty"`
}

// User defines model for User.
type User struct {
	ConfirmPassword *string             `json:"confirm_password,omitempty"`
	Email           *string             `json:"email,omitempty"`
	FirstName       *string             `json:"first_name,omitempty"`
	Id              *openapi_types.UUID `json:"id,omitempty"`
	LastName        *string             `json:"last_name,omitempty"`
	Password        *string             `json:"password,omitempty"`
	Role            *UserRole           `json:"role,omitempty"`
	Username        *string             `json:"username,omitempty"`
}

// UserRole defines model for User.Role.
type UserRole string

// GetAllAlbumsParams defines parameters for GetAllAlbums.
type GetAllAlbumsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetSongsInAlbumParams defines parameters for GetSongsInAlbum.
type GetSongsInAlbumParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetArtistAlbumsParams defines parameters for GetArtistAlbums.
type GetArtistAlbumsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetArtistSongsParams defines parameters for GetArtistSongs.
type GetArtistSongsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// UserLoginJSONBody defines parameters for UserLogin.
type UserLoginJSONBody struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

// GetPurchasedAlbumsParams defines parameters for GetPurchasedAlbums.
type GetPurchasedAlbumsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetPurchasedSongsParams defines parameters for GetPurchasedSongs.
type GetPurchasedSongsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetAllSongsParams defines parameters for GetAllSongs.
type GetAllSongsParams struct {
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchSongsParams defines parameters for SearchSongs.
type SearchSongsParams struct {
	Query  string `form:"query" json:"query"`
	Limit  *int   `form:"limit,omitempty" json:"limit,omitempty"`
	Offset *int   `form:"offset,omitempty" json:"offset,omitempty"`
}

// CreateUserJSONBody defines parameters for CreateUser.
type CreateUserJSONBody struct {
	ConfirmPassword string `json:"confirm_password"`
	Email           string `json:"email"`
	FirstName       string `json:"first_name"`
	LastName        string `json:"last_name"`
	Password        string `json:"password"`
	Username        string `json:"username"`
}

// UpdateUserJSONBody defines parameters for UpdateUser.
type UpdateUserJSONBody struct {
	Email     string `json:"email"`
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
	Password  string `json:"password"`
}

// CreateAlbumJSONRequestBody defines body for CreateAlbum for application/json ContentType.
type CreateAlbumJSONRequestBody = Album

// UpdateAlbumJSONRequestBody defines body for UpdateAlbum for application/json ContentType.
type UpdateAlbumJSONRequestBody = Album

// UserLoginJSONRequestBody defines body for UserLogin for application/json ContentType.
type UserLoginJSONRequestBody UserLoginJSONBody

// CreateSongJSONRequestBody defines body for CreateSong for application/json ContentType.
type CreateSongJSONRequestBody = Song

// UpdateSongJSONRequestBody defines body for UpdateSong for application/json ContentType.
type UpdateSongJSONRequestBody = Song

// CreateUserJSONRequestBody defines body for CreateUser for application/json ContentType.
type CreateUserJSONRequestBody CreateUserJSONBody

// UpdateUserJSONRequestBody defines body for UpdateUser for application/json ContentType.
type UpdateUserJSONRequestBody UpdateUserJSONBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get all albums
	// (GET /albums)
	GetAllAlbums(c *fiber.Ctx, params GetAllAlbumsParams) error
	// Create a new album
	// (POST /albums)
	CreateAlbum(c *fiber.Ctx) error
	// Delete album
	// (DELETE /albums/{albumId})
	DeleteAlbum(c *fiber.Ctx, albumId openapi_types.UUID) error
	// Get details of a specific album
	// (GET /albums/{albumId})
	GetAlbum(c *fiber.Ctx, albumId openapi_types.UUID) error
	// Update album details
	// (PUT /albums/{albumId})
	UpdateAlbum(c *fiber.Ctx, albumId openapi_types.UUID) error
	// Get all songs in an album
	// (GET /albums/{albumId}/songs)
	GetSongsInAlbum(c *fiber.Ctx, albumId openapi_types.UUID, params GetSongsInAlbumParams) error
	// Get all albums by a specific artist
	// (GET /artists/{artistId}/albums)
	GetArtistAlbums(c *fiber.Ctx, artistId openapi_types.UUID, params GetArtistAlbumsParams) error
	// Get artist's dashboard data
	// (GET /artists/{artistId}/dashboard)
	GetArtistDashboard(c *fiber.Ctx, artistId openapi_types.UUID) error
	// Get artist's revenue metrics
	// (GET /artists/{artistId}/revenue-dashboard)
	GetArtistRevenueDashboard(c *fiber.Ctx, artistId openapi_types.UUID) error
	// Get all songs by a specific artist
	// (GET /artists/{artistId}/songs)
	GetArtistSongs(c *fiber.Ctx, artistId openapi_types.UUID, params GetArtistSongsParams) error
	// User login
	// (POST /login)
	UserLogin(c *fiber.Ctx) error
	// Get all purchased albums by a user
	// (GET /purchases/albums/{userId})
	GetPurchasedAlbums(c *fiber.Ctx, userId openapi_types.UUID, params GetPurchasedAlbumsParams) error
	// Get all purchased songs by a user
	// (GET /purchases/songs/{userId})
	GetPurchasedSongs(c *fiber.Ctx, userId openapi_types.UUID, params GetPurchasedSongsParams) error
	// Get all songs
	// (GET /songs)
	GetAllSongs(c *fiber.Ctx, params GetAllSongsParams) error
	// Create a new song
	// (POST /songs)
	CreateSong(c *fiber.Ctx) error
	// Search songs by title, artist, or genre
	// (GET /songs/search)
	SearchSongs(c *fiber.Ctx, params SearchSongsParams) error
	// Delete song
	// (DELETE /songs/{songId})
	DeleteSong(c *fiber.Ctx, songId openapi_types.UUID) error
	// Get details of a specific song
	// (GET /songs/{songId})
	GetSong(c *fiber.Ctx, songId openapi_types.UUID) error
	// Update song details
	// (PUT /songs/{songId})
	UpdateSong(c *fiber.Ctx, songId openapi_types.UUID) error
	// Create a new user
	// (POST /users)
	CreateUser(c *fiber.Ctx) error
	// Delete user
	// (DELETE /users/{userId})
	DeleteUser(c *fiber.Ctx, userId openapi_types.UUID) error
	// Get user details
	// (GET /users/{userId})
	GetUser(c *fiber.Ctx, userId openapi_types.UUID) error
	// Update user details
	// (PUT /users/{userId})
	UpdateUser(c *fiber.Ctx, userId openapi_types.UUID) error
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

type MiddlewareFunc fiber.Handler

// GetAllAlbums operation middleware
func (siw *ServerInterfaceWrapper) GetAllAlbums(c *fiber.Ctx) error {

	var err error

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllAlbumsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetAllAlbums(c, params)
}

// CreateAlbum operation middleware
func (siw *ServerInterfaceWrapper) CreateAlbum(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.CreateAlbum(c)
}

// DeleteAlbum operation middleware
func (siw *ServerInterfaceWrapper) DeleteAlbum(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "albumId" -------------
	var albumId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "albumId", c.Params("albumId"), &albumId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter albumId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.DeleteAlbum(c, albumId)
}

// GetAlbum operation middleware
func (siw *ServerInterfaceWrapper) GetAlbum(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "albumId" -------------
	var albumId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "albumId", c.Params("albumId"), &albumId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter albumId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetAlbum(c, albumId)
}

// UpdateAlbum operation middleware
func (siw *ServerInterfaceWrapper) UpdateAlbum(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "albumId" -------------
	var albumId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "albumId", c.Params("albumId"), &albumId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter albumId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.UpdateAlbum(c, albumId)
}

// GetSongsInAlbum operation middleware
func (siw *ServerInterfaceWrapper) GetSongsInAlbum(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "albumId" -------------
	var albumId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "albumId", c.Params("albumId"), &albumId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter albumId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSongsInAlbumParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetSongsInAlbum(c, albumId, params)
}

// GetArtistAlbums operation middleware
func (siw *ServerInterfaceWrapper) GetArtistAlbums(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "artistId" -------------
	var artistId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "artistId", c.Params("artistId"), &artistId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter artistId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArtistAlbumsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetArtistAlbums(c, artistId, params)
}

// GetArtistDashboard operation middleware
func (siw *ServerInterfaceWrapper) GetArtistDashboard(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "artistId" -------------
	var artistId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "artistId", c.Params("artistId"), &artistId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter artistId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetArtistDashboard(c, artistId)
}

// GetArtistRevenueDashboard operation middleware
func (siw *ServerInterfaceWrapper) GetArtistRevenueDashboard(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "artistId" -------------
	var artistId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "artistId", c.Params("artistId"), &artistId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter artistId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetArtistRevenueDashboard(c, artistId)
}

// GetArtistSongs operation middleware
func (siw *ServerInterfaceWrapper) GetArtistSongs(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "artistId" -------------
	var artistId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "artistId", c.Params("artistId"), &artistId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter artistId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArtistSongsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetArtistSongs(c, artistId, params)
}

// UserLogin operation middleware
func (siw *ServerInterfaceWrapper) UserLogin(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.UserLogin(c)
}

// GetPurchasedAlbums operation middleware
func (siw *ServerInterfaceWrapper) GetPurchasedAlbums(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "userId", c.Params("userId"), &userId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter userId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPurchasedAlbumsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetPurchasedAlbums(c, userId, params)
}

// GetPurchasedSongs operation middleware
func (siw *ServerInterfaceWrapper) GetPurchasedSongs(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "userId", c.Params("userId"), &userId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter userId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPurchasedSongsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetPurchasedSongs(c, userId, params)
}

// GetAllSongs operation middleware
func (siw *ServerInterfaceWrapper) GetAllSongs(c *fiber.Ctx) error {

	var err error

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllSongsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.GetAllSongs(c, params)
}

// CreateSong operation middleware
func (siw *ServerInterfaceWrapper) CreateSong(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.CreateSong(c)
}

// SearchSongs operation middleware
func (siw *ServerInterfaceWrapper) SearchSongs(c *fiber.Ctx) error {

	var err error

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchSongsParams

	var query url.Values
	query, err = url.ParseQuery(string(c.Request().URI().QueryString()))
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for query string: %w", err).Error())
	}

	// ------------- Required query parameter "query" -------------

	if paramValue := c.Query("query"); paramValue != "" {

	} else {
		err = fmt.Errorf("Query argument query is required, but not found")
		c.Status(fiber.StatusBadRequest).JSON(err)
		return err
	}

	err = runtime.BindQueryParameter("form", true, true, "query", query, &params.Query)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter query: %w", err).Error())
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", query, &params.Limit)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter limit: %w", err).Error())
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", query, &params.Offset)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter offset: %w", err).Error())
	}

	return siw.Handler.SearchSongs(c, params)
}

// DeleteSong operation middleware
func (siw *ServerInterfaceWrapper) DeleteSong(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "songId" -------------
	var songId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "songId", c.Params("songId"), &songId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter songId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.DeleteSong(c, songId)
}

// GetSong operation middleware
func (siw *ServerInterfaceWrapper) GetSong(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "songId" -------------
	var songId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "songId", c.Params("songId"), &songId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter songId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetSong(c, songId)
}

// UpdateSong operation middleware
func (siw *ServerInterfaceWrapper) UpdateSong(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "songId" -------------
	var songId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "songId", c.Params("songId"), &songId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter songId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.UpdateSong(c, songId)
}

// CreateUser operation middleware
func (siw *ServerInterfaceWrapper) CreateUser(c *fiber.Ctx) error {

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.CreateUser(c)
}

// DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) DeleteUser(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "userId", c.Params("userId"), &userId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter userId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.DeleteUser(c, userId)
}

// GetUser operation middleware
func (siw *ServerInterfaceWrapper) GetUser(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "userId", c.Params("userId"), &userId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter userId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.GetUser(c, userId)
}

// UpdateUser operation middleware
func (siw *ServerInterfaceWrapper) UpdateUser(c *fiber.Ctx) error {

	var err error

	// ------------- Path parameter "userId" -------------
	var userId openapi_types.UUID

	err = runtime.BindStyledParameter("simple", false, "userId", c.Params("userId"), &userId)
	if err != nil {
		return fiber.NewError(fiber.StatusBadRequest, fmt.Errorf("Invalid format for parameter userId: %w", err).Error())
	}

	c.Context().SetUserValue(BearerAuthScopes, []string{})

	return siw.Handler.UpdateUser(c, userId)
}

// FiberServerOptions provides options for the Fiber server.
type FiberServerOptions struct {
	BaseURL     string
	Middlewares []MiddlewareFunc
}

// RegisterHandlers creates http.Handler with routing matching OpenAPI spec.
func RegisterHandlers(router fiber.Router, si ServerInterface) {
	RegisterHandlersWithOptions(router, si, FiberServerOptions{})
}

// RegisterHandlersWithOptions creates http.Handler with additional options
func RegisterHandlersWithOptions(router fiber.Router, si ServerInterface, options FiberServerOptions) {
	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	for _, m := range options.Middlewares {
		router.Use(m)
	}

	router.Get(options.BaseURL+"/albums", wrapper.GetAllAlbums)

	router.Post(options.BaseURL+"/albums", wrapper.CreateAlbum)

	router.Delete(options.BaseURL+"/albums/:albumId", wrapper.DeleteAlbum)

	router.Get(options.BaseURL+"/albums/:albumId", wrapper.GetAlbum)

	router.Put(options.BaseURL+"/albums/:albumId", wrapper.UpdateAlbum)

	router.Get(options.BaseURL+"/albums/:albumId/songs", wrapper.GetSongsInAlbum)

	router.Get(options.BaseURL+"/artists/:artistId/albums", wrapper.GetArtistAlbums)

	router.Get(options.BaseURL+"/artists/:artistId/dashboard", wrapper.GetArtistDashboard)

	router.Get(options.BaseURL+"/artists/:artistId/revenue-dashboard", wrapper.GetArtistRevenueDashboard)

	router.Get(options.BaseURL+"/artists/:artistId/songs", wrapper.GetArtistSongs)

	router.Post(options.BaseURL+"/login", wrapper.UserLogin)

	router.Get(options.BaseURL+"/purchases/albums/:userId", wrapper.GetPurchasedAlbums)

	router.Get(options.BaseURL+"/purchases/songs/:userId", wrapper.GetPurchasedSongs)

	router.Get(options.BaseURL+"/songs", wrapper.GetAllSongs)

	router.Post(options.BaseURL+"/songs", wrapper.CreateSong)

	router.Get(options.BaseURL+"/songs/search", wrapper.SearchSongs)

	router.Delete(options.BaseURL+"/songs/:songId", wrapper.DeleteSong)

	router.Get(options.BaseURL+"/songs/:songId", wrapper.GetSong)

	router.Put(options.BaseURL+"/songs/:songId", wrapper.UpdateSong)

	router.Post(options.BaseURL+"/users", wrapper.CreateUser)

	router.Delete(options.BaseURL+"/users/:userId", wrapper.DeleteUser)

	router.Get(options.BaseURL+"/users/:userId", wrapper.GetUser)

	router.Put(options.BaseURL+"/users/:userId", wrapper.UpdateUser)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
